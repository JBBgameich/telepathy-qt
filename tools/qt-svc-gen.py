#!/usr/bin/python
#
# Copyright (C) 2012 Collabora Limited <http://www.collabora.co.uk>
# Copyright (C) 2012 Nokia Corporation
# Copyright (C) 2016 George Kiagiadakis <gkiagia@tolabaki.gr>
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

from sys import argv
import xml.dom.minidom
import codecs
from getopt import gnu_getopt

from libtpcodegen import NS_TP, get_descendant_text, get_by_path
from libqtcodegen import binding_from_usage, extract_arg_or_member_info, format_docstring, gather_externals, gather_custom_lists, get_headerfile_cmd, get_qt_name, qt_identifier_escape, RefRegistry

def to_lower_camel_case(s):
    if len(s) <= 1:
        return s.lower()

    i = 0
    for c in s:
        if c == '_':
            break
        i += 1

    ret = s
    if i == len(s):
        return s.lower()
    else:
        ret = s[0:i].lower() + s[i:]
    ret = ret.replace('_', '')
    return ret

class Generator(object):
    def __init__(self, opts):
        try:
            self.group = opts.get('--group', '')
            self.headerfile = opts['--headerfile']
            self.privheaderfile = opts['--privheaderfile']
            self.implfile = opts['--implfile']
            self.namespace = opts['--namespace']
            self.typesnamespace = opts['--typesnamespace']
            self.realinclude = opts.get('--realinclude', None)
            self.privheaderinclude = opts.get('--privheaderinclude', None)
            self.mocinclude = opts.get('--mocinclude', None)
            self.privmocinclude = opts.get('--privmocinclude', None)
            self.prettyinclude = opts.get('--prettyinclude')
            self.extraincludes = opts.get('--extraincludes', None)
            self.must_define = opts.get('--must-define', None)
            self.visibility = opts.get('--visibility', '')
            self.no_visibility = opts.get('--no-visibility', '')
            ifacedom = xml.dom.minidom.parse(opts['--ifacexml'])
            specdom = xml.dom.minidom.parse(opts['--specxml'])
        except KeyError, k:
            assert False, 'Missing required parameter %s' % k.args[0]

        if not self.realinclude:
            self.realinclude = self.headerfile
        if not self.privheaderinclude:
            self.privheaderinclude = self.privheaderfile

        self.hs = []
        self.rs = []
        self.bs = []
        self.ifacenodes = ifacedom.getElementsByTagName('node')
        self.spec, = get_by_path(specdom, "spec")
        self.custom_lists = gather_custom_lists(self.spec, self.typesnamespace)
        self.externals = gather_externals(self.spec)
        self.refs = RefRegistry(self.spec)

    def __call__(self):
        # Output info header and includes
        self.do_includes()

        # Begin namespace
        for ns in self.namespace.split('::'):
            self.hrb("""\
namespace %s
{
""" % ns)

        # Output interface proxies
        def ifacenodecmp(x, y):
            xname, yname = [node.getAttribute('name').replace('/', '').replace('_', '') for node in x, y]
            return cmp(xname, yname)

        self.ifacenodes.sort(cmp=ifacenodecmp)
        for ifacenode in self.ifacenodes:
            self.do_ifacenode(ifacenode)

        # End namespace
        self.hrb(''.join(['\n}' for ns in self.namespace.split('::')]))
        self.hrb('\n') # eof newline

        # Write output to files
        (codecs.getwriter('utf-8')(open(self.headerfile, 'w'))).write(''.join(self.hs))
        (codecs.getwriter('utf-8')(open(self.privheaderfile, 'w'))).write(''.join(self.rs))
        (codecs.getwriter('utf-8')(open(self.implfile, 'w'))).write(''.join(self.bs))

    def do_includes(self):
        self.h("""\
/*
 * This file contains D-Bus interface adaptee classes generated by qt-svc-gen.py.
 *
 * This file can be distributed under the same terms as the specification from
 * which it was generated.
 */
""")

        if self.must_define:
            self.h('\n')
            self.h('#ifndef %s\n' % self.must_define)
            self.h('#error %s\n' % self.must_define)
            self.h('#endif\n')

        self.h('\n')

        if self.extraincludes:
            for include in self.extraincludes.split(','):
                self.hr('#include %s\n' % include)

        self.r('#include "%s"\n' % self.realinclude)
        self.r('#include <QtDBus>\n')

        self.h("""
#include <TelepathyQt/Global>
#include <TelepathyQt/Types>
#include <TelepathyQt/Callbacks>
#include <TelepathyQt/AbstractDBusInterfaceAdaptee>
""")
        self.hr('\n')


        if self.must_define:
            self.b('#define %s\n' % (self.must_define))

        # realinclude is included from the private header;
        # we don't have header guards, so don't include twice
        #self.b('#include "%s"\n' % self.realinclude)
        self.b('#include "%s"\n' % self.privheaderinclude)

        if self.mocinclude:
            self.b('#include "%s"\n' % self.mocinclude)

        if self.privmocinclude:
            self.b('#include "%s"\n' % self.privmocinclude)

        self.b("""
#include <TelepathyQt/Constants>
#include <TelepathyQt/MethodInvocationContext>

""")

    def do_ifacenode(self, ifacenode):
        # Extract info
        adaptor_name = ifacenode.getAttribute('name').replace('/', '').replace('_', '') + 'Adaptor'
        adaptee_name = ifacenode.getAttribute('name').replace('/', '').replace('_', '') + 'Adaptee'
        iface, = get_by_path(ifacenode, 'interface')
        dbusname = iface.getAttribute('name')
        props = get_by_path(iface, 'property')
        methods = get_by_path(iface, 'method')
        signals = get_by_path(iface, 'signal')

        # Begin Adaptee
        self.h("""
class %(adaptee_name)s;
typedef SharedPtr<%(adaptee_name)s> %(adaptee_name)sPtr;

/**
 * \\class %(adaptee_name)s
%(headercmd)s\
%(groupcmd)s\
 *
 * Adaptee class providing a 1:1 mapping of the D-Bus interface "%(dbusname)s".
 */
class %(visibility)s %(adaptee_name)s : public Tp::AbstractDBusInterfaceAdaptee
{
    Q_OBJECT
    Q_DISABLE_COPY(%(adaptee_name)s)
""" % {'adaptee_name': adaptee_name,
       'visibility': self.visibility,
       'headercmd': get_headerfile_cmd(self.realinclude, self.prettyinclude),
       'groupcmd': self.group and (' * \\ingroup %s\n' % self.group),
       'dbusname': dbusname,
      })

        # Begin Adaptor
        self.r("""
class %(no_visibility)s %(adaptor_name)s : public QDBusAbstractAdaptor
{
    Q_OBJECT
    Q_CLASSINFO("D-Bus Interface", "%(dbusname)s")
    Q_CLASSINFO("D-Bus Introspection", ""
"  <interface name=\\"%(dbusname)s\\">\\n"
""" % {'adaptor_name': adaptor_name,
       'dbusname': dbusname,
       'no_visibility': self.no_visibility,
       })

        self.do_introspection(props, methods, signals)

        self.r("""\
"  </interface>\\n"
"")
""")

        # Q_PROPERTY declarations
        self.do_qprops(props)

        # Adaptee::Private
        self.b("""
struct %(no_visibility)s %(adaptee_name)s::Private
{
    QPointer<%(adaptor_name)s> adaptor;
""" % {'adaptee_name': adaptee_name,
       'adaptor_name': adaptor_name,
       'no_visibility': self.no_visibility})

        self.do_prop_variables(props)
        self.do_callback_variables(methods)

        self.b("""\
};
""")

        # Adaptee constructors & overriden methods
        self.h("""
protected:
    %(adaptee_name)s();
    void createAdaptor(QObject *parent) Q_DECL_OVERRIDE;

public:
    static %(adaptee_name)sPtr create() {
        return %(adaptee_name)sPtr(new %(adaptee_name)s());
    }
    virtual ~%(adaptee_name)s();

    QString interfaceName() const Q_DECL_OVERRIDE;
""" % {'adaptee_name': adaptee_name})

        self.b("""
%(adaptee_name)s::%(adaptee_name)s()
    : Tp::AbstractDBusInterfaceAdaptee(),
      mPriv(new Private)
{
}

%(adaptee_name)s::~%(adaptee_name)s()
{
    delete mPriv;
}

void %(adaptee_name)s::createAdaptor(QObject *parent)
{
    mPriv->adaptor = new %(adaptor_name)s(%(adaptee_name)sPtr(this), parent);
}

QString %(adaptee_name)s::interfaceName() const
{
    return QStringLiteral("%(dbusname)s");
}
""" % {'adaptee_name': adaptee_name,
       'adaptor_name': adaptor_name,
       'dbusname': dbusname})

        # Adaptor constructors
        self.r("""
public:
    %(adaptor_name)s(const %(adaptee_name)sPtr &adaptee, QObject* dbusObject);
""" % {'adaptor_name': adaptor_name,
       'adaptee_name': adaptee_name})

        self.b("""
%(adaptor_name)s::%(adaptor_name)s(const %(adaptee_name)sPtr& adaptee, QObject* dbusObject)
    : QDBusAbstractAdaptor(dbusObject),
      mAdaptee(adaptee)
{
    setAutoRelaySignals(false);
}
""" % {'adaptor_name': adaptor_name,
       'adaptee_name': adaptee_name
       })

        # Properties
        if props:
            self.hr("""
public: // PROPERTIES
""")

            for prop in props:
                # Skip tp:properties
                if not prop.namespaceURI:
                    self.do_prop(adaptee_name, adaptor_name, prop)

        # Methods
        if methods:
            self.h("""
public: // METHODS
""")
            self.r("""
public Q_SLOTS: // METHODS
""")

            for method in methods:
                self.do_method(adaptee_name, adaptor_name, method)

        # Signals
        if signals:
            self.h("""
public Q_SLOTS: // SIGNALS
""")
            self.r("""
Q_SIGNALS: // SIGNALS
""")

            for signal in signals:
                self.do_signal(adaptee_name, signal)

        # Close class
        self.h("""
private:
    struct Private;
    friend struct Private;
    Private *mPriv;
};
""")

        self.r("""
private:
    %(adaptee_name)sPtr mAdaptee;
};
""" % {'adaptee_name': adaptee_name})

    def do_introspection(self, props, methods, signals):
        self.do_prop_introspection(props)
        self.do_method_introspection(methods)
        self.do_signal_introspection(signals)

    def do_prop_introspection(self, props):
        for prop in props:
            if prop.namespaceURI:
                continue

            name = prop.getAttribute('name')
            access = prop.getAttribute('access')
            sig = prop.getAttribute('type')
            tptype = prop.getAttributeNS(NS_TP, 'type')
            binding = binding_from_usage(sig, tptype, self.custom_lists, (sig, tptype) in self.externals, self.typesnamespace)

            if not binding.custom_type:
                self.r("""\
"    <property access=\\"%(access)s\\" type=\\"%(sig)s\\" name=\\"%(name)s\\"/>\\n"
""" % {'access': access,
       'sig': sig,
       'name': name,
       })
            else:
                self.r("""\
"    <property access=\\"%(access)s\\" type=\\"%(sig)s\\" name=\\"%(name)s\\">\\n"
"      <annotation value=\\"%(type)s\\" name=\\"org.qtproject.QtDBus.QtTypeName\\"/>\\n"
"    </property>\\n"
""" % {'access': access,
       'sig': sig,
       'name': name,
       'type': binding.val,
       })

    def do_method_introspection(self, methods):
        for method in methods:
            name = method.getAttribute('name')
            args = get_by_path(method, 'arg')
            argnames, argdocstrings, argbindings = extract_arg_or_member_info(args,
                self.custom_lists, self.externals, self.typesnamespace, self.refs, '     *     ')

            if not argnames:
                self.r("""\
"    <method name=\\"%(name)s\\"/>\\n"
""" % {'name': name})
            else:
                self.r("""\
"    <method name=\\"%(name)s\\">\\n"
""" % {'name': name})

                outindex = 0
                inindex = 0
                for i in xrange(len(argnames)):
                    assert argnames[i] != None, 'Name missing from argument at index %d for signal %s' % (i, name)

                    argbinding = argbindings[i]
                    argname = argnames[i]
                    argsig = args[i].getAttribute('type')
                    argdirection = args[i].getAttribute('direction')

                    # QtDBus requires annotating a{sv}
                    if argsig == 'a{sv}':
                        argbinding.custom_type = True

                    if not argbinding.custom_type:
                        self.r("""\
"      <arg direction=\\"%(direction)s\\" type=\\"%(sig)s\\" name=\\"%(name)s\\"/>\\n"
""" % {'direction': argdirection,
       'sig': argsig,
       'name': argname})
                    else:
                        self.r("""\
"      <arg direction=\\"%(direction)s\\" type=\\"%(sig)s\\" name=\\"%(name)s\\">\\n"
"        <annotation value=\\"%(type)s\\" name=\\"org.qtproject.QtDBus.QtTypeName.%(index)s\\"/>\\n"
"      </arg>\\n"
""" % {'direction': argdirection,
       'sig': argsig,
       'name': argname,
       'type': argbinding.val,
       'index': 'In' + str(inindex) if argdirection == 'in' else 'Out' + str(outindex),
       })

                    if argdirection == 'out':
                        outindex += 1
                    else:
                        inindex += 1

                self.r("""\
"    </method>\\n"
""")

    def do_signal_introspection(self, signals):
        for signal in signals:
            name = signal.getAttribute('name')
            args = get_by_path(signal, 'arg')
            argnames, argdocstrings, argbindings = extract_arg_or_member_info(args,
                self.custom_lists, self.externals, self.typesnamespace, self.refs, '     *     ')

            if not argnames:
                self.r("""\
"    <signal name=\\"%(name)s\\"/>\\n"
""" % {'name': name})
            else:
                self.r("""\
"    <signal name=\\"%(name)s\\">\\n"
""" % {'name': name})

                for i in xrange(len(argnames)):
                    assert argnames[i] != None, 'Name missing from argument at index %d for signal %s' % (i, name)

                    argbinding = argbindings[i]
                    argname = argnames[i]
                    argsig = args[i].getAttribute('type')

                    if not argbinding.custom_type:
                        self.r("""\
"      <arg type=\\"%(sig)s\\" name=\\"%(name)s\\"/>\\n"
""" % {'sig': argsig,
       'name': argname})
                    else:
                        self.r("""\
"      <arg type=\\"%(sig)s\\" name=\\"%(name)s\\">\\n"
"        <annotation value=\\"%(type)s\\" name=\\"org.qtproject.QtDBus.QtTypeName.In%(index)d\\"/>\\n"
"      </arg>\\n"
""" % {'sig': argsig,
       'name': argname,
       'type': argbinding.val,
       'index': i,
       })

                self.r("""\
"    </signal>\\n"
""")

    def do_prop_variables(self, props):
        for prop in props:
            # Skip tp:properties
            if not prop.namespaceURI:
                bindings_name = prop.getAttribute('tp:name-for-bindings')
                sig = prop.getAttribute('type')
                tptype = prop.getAttributeNS(NS_TP, 'type')
                binding = binding_from_usage(sig, tptype, self.custom_lists, (sig, tptype) in self.externals, self.typesnamespace)

                if '_' not in bindings_name and sig == 'b':
                    var_name = to_lower_camel_case('Is_' + bindings_name)
                else:
                    var_name = to_lower_camel_case(bindings_name)

                initializers = {
                    'b' : 'false', # bool
                    'y' : '0', # uchar
                    'n' : '0', # short
                    'q' : '0', # ushort
                    'i' : '0', # int
                    'u' : '0', # uint
                    'x' : '0ll',  # qlonglong
                    't' : '0ull', # qulonglong
                    'd' : '0.0', # double
                    }
                if initializers.has_key(sig):
                    initializer = ' = ' + initializers[sig]
                else:
                    initializer = ''

                self.b("""\
    %(type)s %(var_name)s%(initializer)s;
""" % {'type': binding.val,
       'var_name': var_name,
       'initializer': initializer})

    def do_qprops(self, props):
        for prop in props:
            # Skip tp:properties
            if not prop.namespaceURI:
                self.do_qprop(prop)

    def do_qprop(self, prop):
        name = prop.getAttribute('name')
        access = prop.getAttribute('access')
        sig = prop.getAttribute('type')
        tptype = prop.getAttributeNS(NS_TP, 'type')
        binding = binding_from_usage(sig, tptype, self.custom_lists, (sig, tptype) in self.externals, self.typesnamespace)

        adaptor_getter = name
        adaptor_setter = None
        if 'write' in access:
            adaptor_setter = 'Set' + name

        self.r("""\
    Q_PROPERTY(%(type)s %(property)s %(getter)s %(setter)s)
""" % {'type': binding.val,
       'property': name,
       'getter': 'READ ' + adaptor_getter,
       'setter': 'WRITE ' + adaptor_setter if adaptor_setter else '',
       })

    def do_prop(self, adaptee_name, adaptor_name, prop):
        name = prop.getAttribute('name')
        bindings_name = prop.getAttribute('tp:name-for-bindings')
        access = prop.getAttribute('access')
        sig = prop.getAttribute('type')
        tptype = prop.getAttributeNS(NS_TP, 'type')
        binding = binding_from_usage(sig, tptype, self.custom_lists, (sig, tptype) in self.externals, self.typesnamespace)

        docstring = format_docstring(prop, self.refs, '     * ').replace('*/', '&#42;&#47;')

        if '_' not in bindings_name and sig == 'b':
            adaptee_getter = to_lower_camel_case('Is_' + bindings_name)
        else:
            adaptee_getter = to_lower_camel_case(bindings_name)
        adaptee_setter = to_lower_camel_case('Set_' + bindings_name)
        adaptee_variable = adaptee_getter
        adaptee_notifier = to_lower_camel_case(bindings_name + '_Changed')

        adaptor_getter = name
        adaptor_setter = None
        if 'write' in access:
            adaptor_setter = 'Set' + name

        # Getters
        self.h("""
    /**
     * The exported D-Bus property \\c %(name)s.
     *
%(docstring)s\
     *
     * \\return The value of the exported D-Bus property \\c %(name)s.
     */
    %(type)s %(adaptee_getter)s() const;
""" % {'adaptee_getter': adaptee_getter,
       'type': binding.val,
       'name': name,
       'docstring': docstring,
       })

        self.r("""\
    %(type)s %(adaptor_getter)s() const;
""" % {'adaptor_getter': adaptor_getter,
       'type': binding.val,
       })

        self.b("""
%(type)s %(adaptee_name)s::%(adaptee_getter)s() const
{
    return mPriv->%(adaptee_variable)s;
}

%(type)s %(adaptor_name)s::%(adaptor_getter)s() const
{
    return mAdaptee->%(adaptee_getter)s();
}
""" % {'type': binding.val,
       'adaptee_name': adaptee_name,
       'adaptee_getter': adaptee_getter,
       'adaptee_variable': adaptee_variable,
       'adaptor_name': adaptor_name,
       'adaptor_getter': adaptor_getter,
       })

        # Setters
        self.h("""
    /**
     * Sets the value of the exported D-Bus property \\c %(name)s
     */
    void %(adaptee_setter)s(const %(type)s &newValue);
""" % {'adaptee_setter': adaptee_setter,
       'type': binding.val,
       'name': name,
       })

        self.h("""
    /**
     * Emitted when the exported D-Bus property \\c %(name)s was changed, either by
     * a remote D-Bus call or locally.
     */
    Q_SIGNAL void %(adaptee_notifier)s();
""" % {'adaptee_notifier': adaptee_notifier,
       'name': name,
       })

        if 'write' in access:
            self.r("""\
    void %(adaptor_setter)s(const %(type)s &newValue);
""" % {'adaptor_setter': adaptor_setter,
       'type': binding.val,
       })

        self.b("""
void %(adaptee_name)s::%(adaptee_setter)s(const %(type)s &newValue)
{
    mPriv->%(adaptee_variable)s = newValue;
    Q_EMIT %(adaptee_notifier)s();
}
""" % {'adaptee_name': adaptee_name,
       'adaptee_setter': adaptee_setter,
       'type': binding.val,
       'adaptee_variable': adaptee_variable,
       'adaptee_notifier': adaptee_notifier,
       })

        if 'write' in access:
            self.b("""
void %(adaptor_name)s::%(adaptor_setter)s(const %(type)s &newValue)
{
    mAdaptee->%(adaptee_setter)s(newValue);
}
""" % {'adaptor_name': adaptor_name,
       'adaptor_setter': adaptor_setter,
       'adaptee_setter': adaptee_setter,
       'type': binding.val,
       })

    def do_callback_variables(self, methods):
        for method in methods:
            name = method.getAttribute('name')
            bindings_name = to_lower_camel_case(method.getAttribute('tp:name-for-bindings'))
            self.b("""\
    %(name)sCallback %(bindings_name)sCb;
""" % {'name': name,
       'bindings_name': bindings_name})

    def do_method(self, adaptee_name, adaptor_name, method):
        name = method.getAttribute('name')
        bindings_name = to_lower_camel_case(method.getAttribute('tp:name-for-bindings'))
        args = get_by_path(method, 'arg')
        argnames, argdocstrings, argbindings = extract_arg_or_member_info(args, self.custom_lists,
                self.externals, self.typesnamespace, self.refs, '     *     ')
        docstring = format_docstring(method, self.refs, '     * ').replace('*/', '&#42;&#47;')

        inargs = []
        outargs = []

        for i in xrange(len(args)):
            if args[i].getAttribute('direction') == 'out':
                outargs.append(i)
            else:
                inargs.append(i)
                assert argnames[i] != None, 'No argument name for input argument at index %d for method %s' % (i, name)

        # Adaptor signature
        adaptor_params = [argbindings[i].inarg + ' ' + argnames[i] for i in inargs]
        adaptor_params.append('const QDBusMessage& dbusMessage')
        adaptor_params += [argbindings[i].outarg + ' ' + argnames[i] for i in outargs[1:]]
        adaptor_params = ', '.join(adaptor_params)

        if outargs:
            adaptor_rettype = argbindings[outargs[0]].val
        else:
            adaptor_rettype = 'void'

        # Adaptee signature
        adaptee_params = [argbindings[i].inarg + ' ' + argnames[i] for i in inargs]
        adaptee_params.append('const %sContextPtr& context' % name)
        adaptee_params = ', '.join(adaptee_params)

        # ContextPtr signature
        if outargs:
            outargtypes = ', '.join([argbindings[i].val for i in outargs])
        else:
            outargtypes = ''

        # Callback signature
        callback_types = [argbindings[i].val for i in inargs]
        callback_types.append('%sContextPtr' % name)
        callback_argcount = len(callback_types)
        callback_types = ', '.join(callback_types)

        # Argument names to invoke the adaptee method and the callback
        implinvokeargs = [argnames[i] for i in inargs]
        implinvokeargs.append('context')
        implinvokeargs = ', '.join(implinvokeargs)

        self.h("""
    typedef Tp::MethodInvocationContextPtr< %(outargtypes)s > %(name)sContextPtr;
    typedef Tp::Callback%(callback_argcount)d<void, %(callback_types)s> %(name)sCallback;
""" % {'name': name,
       'outargtypes': outargtypes,
       'callback_argcount': callback_argcount,
       'callback_types': callback_types,
       })

        self.h("""
    /**
     * Begins a call to the exported D-Bus method \\c %(name)s on this object.
     *
     * This method is meant to be called by the D-Bus adaptor only. By default
     * it returns a "not implemented" error. You can implement its logic by
     * setting a callback using implement%(name)s()
     *
     * Implementations should call MethodInvocationContext::setFinished (or setFinishedWithError
     * accordingly) on the received \\a context object once the method has finished processing.
     *
%(docstring)s\
     *
""" % {'name': name,
       'docstring': docstring
       })

        for i in inargs:
            if argdocstrings[i]:
                self.h("""\
     * \\param %s
%s\
""" % (argnames[i], argdocstrings[i]))

        for i in outargs[1:]:
            if argdocstrings[i]:
                self.h("""\
     * \\param %s Output parameter
%s\
""" % (argnames[i], argdocstrings[i]))

        if outargs:
                self.h("""\
     * \\return
%s\
""" % argdocstrings[outargs[0]])

        self.h("""\
     */
    void %(bindings_name)s(%(adaptee_params)s);
    void implement%(name)s(const %(name)sCallback& cb);

""" % {'name': name,
       'bindings_name': bindings_name,
       'adaptee_params': adaptee_params
       })

        self.r("""\
    %(adaptor_rettype)s %(name)s(%(adaptor_params)s);
""" % {'adaptor_rettype': adaptor_rettype,
       'name': name,
       'adaptor_params': adaptor_params
       })

        self.b("""
void %(adaptee_name)s::%(bindings_name)s(%(adaptee_params)s)
{
    if (mPriv->%(bindings_name)sCb.isValid()) {
        mPriv->%(bindings_name)sCb(%(implinvokeargs)s);
    } else {
        context->setFinishedWithError(TP_QT_ERROR_NOT_IMPLEMENTED,
            QStringLiteral("Not implemented"));
    }
}

void %(adaptee_name)s::implement%(name)s(const %(name)sCallback& cb)
{
    mPriv->%(bindings_name)sCb = cb;
}

%(adaptor_rettype)s %(adaptor_name)s::%(name)s(%(adaptor_params)s)
{
    %(adaptee_name)s::%(name)sContextPtr context =
            %(adaptee_name)s::%(name)sContextPtr(
                    new Tp::MethodInvocationContext< %(outargtypes)s >(
                            mAdaptee->dbusObject()->dbusConnection(), dbusMessage));
    mAdaptee->%(bindings_name)s(%(implinvokeargs)s);
""" % {'adaptor_rettype': adaptor_rettype,
       'name': name,
       'bindings_name': bindings_name,
       'adaptee_name': adaptee_name,
       'adaptor_name': adaptor_name,
       'adaptee_params': adaptee_params,
       'adaptor_params': adaptor_params,
       'implinvokeargs': implinvokeargs,
       'outargtypes': outargtypes,
       })

        if adaptor_rettype != 'void':
            self.b("""\
    return %(adaptor_rettype)s();
""" % {'adaptor_rettype': adaptor_rettype})

        self.b("}\n")

    def do_signal(self, adaptee_name, signal):
        name = signal.getAttribute('name')
        argnames, argdocstrings, argbindings = extract_arg_or_member_info(get_by_path(signal,
            'arg'), self.custom_lists, self.externals, self.typesnamespace, self.refs, '     *     ')
        docstring = format_docstring(signal, self.refs, '     * ').replace('*/', '&#42;&#47;')

        params = ', '.join(['%s %s' % (binding.inarg, param_name) for binding, param_name in zip(argbindings, argnames)])

        self.h("""
    /**
     * Emits the exported D-Bus signal \\c %(name)s on this object.
     *
%(docstring)s\
     *
""" % {'name': name,
       'docstring': docstring,
       })

        for i in xrange(len(argnames)):
            assert argnames[i] != None, 'Name missing from argument at index %d for signal %s' % (i, name)
            if argdocstrings[i]:
                self.h("""\
     * \\param %s
%s\
""" % (argnames[i], argdocstrings[i]))

        self.h("""\
     */
    void emit%(name)s(%(params)s);
""" % {'name': name,
       'params': params
       })

        self.r("""\
    void %(name)s(%(params)s);
""" % {'name': name,
       'params': params
       })

        self.b("""
void %(adaptee_name)s::emit%(name)s(%(params)s)
{
    if (mPriv->adaptor)
        Q_EMIT mPriv->adaptor->%(name)s(%(invokeargs)s);
}
""" % {'name': name,
       'adaptee_name': adaptee_name,
       'params': params,
       'invokeargs': ', '.join(argnames),
       })

    def h(self, str):
        self.hs.append(str)

    def r(self, str):
        self.rs.append(str)

    def b(self, str):
        self.bs.append(str)

    def hr(self, str):
        self.h(str)
        self.r(str)

    def hrb(self, str):
        self.h(str)
        self.r(str)
        self.b(str)


if __name__ == '__main__':
    options, argv = gnu_getopt(argv[1:], '',
            ['group=',
             'headerfile=',
             'privheaderfile=',
             'implfile=',
             'namespace=',
             'typesnamespace=',
             'realinclude=',
             'privheaderinclude=',
             'mocinclude=',
             'privmocinclude=',
             'prettyinclude=',
             'extraincludes=',
             'must-define=',
             'visibility=',
             'no-visibility=',
             'ifacexml=',
             'specxml='])

    Generator(dict(options))()
